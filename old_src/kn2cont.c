/***************************************************************************
  KnCont - a code generator for kc and KN's continuation program. 
  
  CopyWrong 1993-1995 by 
  Kenneth Geisshirt (kneth@fatou.ruc.dk)
  Department of Life Sciences and Chemistry
  Roskilde University
  P.O. Box 260
  4000 Roskilde
  Denmark

  and
  Keld Nielsen (kneth@kiku.dk)
    Department of Theoretical Chemistry
  H.C. Orsted Institute
  Universitetsparken 5
  2100 Copenhagen
  Denmark

  See kc.tex for details.

  Last updated: 17 Febrary 1995 by KG
*****************************************************************************/

#include <stdio.h>
#include <malloc.h>
#include <time.h>
#include <math.h>
#include "config.h"
#include "symbmath.h"
#include "tableman.h"
#include "codegen.h"
#include "misc.h"

void KnCont(FILE *code) {

  double charge, temp, coeff, temp1, temp2;
  char   *name, *rename;
  time_t timer;
  Tree   v_temp, tmp, temp_tree, tmp2;
  int    i, j, k, l, react_no, finished, constraint, dyn, dyn2, dyn3, form;
  int    NumbOfParams, NumbOfDynVars;
  int    need_dd_jac;

  name=StringAlloc();
  rename=StringAlloc();
  timer=time(&timer);
  NumbOfParams=NumOfParameter();
  NumbOfDynVars=NoOfSpec()-NumOfConstraint()+NumOfDynVar();
  if ((NumbOfParams==0) || (NumbOfParams>2)) {
    fprintf(stderr, "KNCont: Wrong number of parameters - should be either 1 or 2.\n");
    return;
  } /* if */

  InitCodeGenVar(NoOfSpec()+NumOfDynVar()-NumOfConstraint(),
		 NumOfConstraint());
  GenerateRateExpr();
  GenerateJacobi();
  if (NumbOfParams==2) {
    GenerateHessian();
    GenerateKeldian();
  } /* if */

  fprintf(code, "(******************************************************\n");
  fprintf(code, "  WARNING: This file was generated by kc v%s\n", 
	  VERSION);
  fprintf(code, "  CopyWrong 1994 by Kenneth Geisshirt.\n");
  fprintf(code, "  %s", ctime(&timer));
  fprintf(code, "*******************************************************)\n");
  fprintf(code, "CONST\n");
  fprintf(code, "n=%d;\n", NumbOfDynVars);
  fprintf(code, "np=%d;\n", NumbOfDynVars);
  fprintf(code, "numparam=%d;\n\n", NumbOfParams);
  fprintf(code, "VAR\n");
  fprintf(code, "NeedDDJac:BOOLEAN;\n");
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    RenameSpec(rename, name, charge);
    fprintf(code, "%s:LONGREAL;\n", rename);
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(code, "%s:LONGREAL;\n", name);
  } /* for i */
  for(i=1; i<=(NoOfReact()+NumOfExpr()); i++) {
    fprintf(code, "(*  r%d : LONGREAL; *)\n", i-1);
  } /* for i */
  for(i=1; i<=NumOfParameter(); i++) {
    GetParamNo(i, name, &charge, &form);
    if (form==1)
      strcpy(rename, name);
    else
      RenameSpec(rename, name, charge);
    fprintf(code, "%s:LONGREAL;\n", rename);
  } /* for i */
  fprintf(code, "species : ARRAY[1..n] OF STRING[20];\n");
  fprintf(code, "\n(* FILE LIMIT *)\n\n");

  fprintf(code, "PROCEDURE derivs(bj:BOOLEAN; xx_:glnarray; t:LONGREAL;\n");
  fprintf(code, "                 VAR vv_:glnarray; VAR jj_:glnpbynp);\n");
  fprintf(code, "BEGIN\n");
  dyn=1;
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    RenameSpec(rename, name, charge);
    constraint=IsSpecInConstraint(name, charge);
    if (constraint==0) {  
      fprintf(code, "%s:=xx_[%d];\n", rename, dyn);
      dyn++;
    } /* if */
  } /* for i*/
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(code, "%s:=xx_[%d];\n", name, i+NoOfSpec()-NumOfConstraint());
  } /* for i */
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    RenameSpec(rename, name, charge);
    constraint=IsSpecInConstraint(name, charge);
    if (constraint>0) {  
      fprintf(code, "%s:=", rename);
      TreePrint(con[constraint-1], 2, code);
      fprintf(code, ";\n");
    }; /* if */
  }; /* for i */

  for(i=1; i<=NumbOfDynVars; i++) {
    fprintf(code, "vv_[%d]:=", i); 
    TreePrint(v[i-1], 2, code);
    fprintf(code, ";\n");
  } /* for i */
  fprintf(code, "IF bj THEN BEGIN\n");
  for(i=1; i<=NumbOfDynVars; i++) {
    for(j=1; j<=NumbOfDynVars; j++) {
      fprintf(code, "jj_[%d, %d]:=", i, j);
      TreePrint(jacobi[i-1][j-1], 2, code);
      fprintf(code, ";\n");
    } /* for j */
  } /* for i */
  fprintf(code, "END\nEND;\n");
  
  /* Diff. with respect to parameters, i.e. df/dalpha */
  fprintf(code, "PROCEDURE derivsdalfa(bjac: BOOLEAN;xx_: glnarray; VAR gg: glnpbynp);\n");
  fprintf(code, "BEGIN\n");
  dyn=1;
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if ((IsSpecInConstraint(name, charge)==0) && 
	(IsSpecParam(name, charge)!=1)) {
      RenameSpec(rename, name, charge);
      fprintf(code, "%s:=xx_[%d];\n", rename, dyn);
      dyn++;
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(code, "%s:=xx_[%d];\n", name, i+NoOfSpec()-NumOfConstraint());
  } /* for i */
  switch (NumbOfParams) {
  case 1:
    GetParamNo(1, name, &charge, &form);
    if (form==2)
      RenameSpec(rename, name, charge);
    else
      strcpy(rename, name);
    fprintf(code, "%s:=xx_[n1];\n", rename);
    fprintf(code, "IF bjac THEN\nBEGIN\n");
    GetParamNo(1, name, &charge, &form);
    if (form==1)
      strcpy(rename, name);
    else
      RenameSpec(rename, name, charge);
    for(j=0; j<NumbOfDynVars; j++) {
      tmp=TreeCreate();
      TreeDerive(tmp, v[j], rename);
      fprintf(code, "gg_[%d, n1]:=", j);
      TreePrint(tmp, 2, code);
      fprintf(code, ";\n");
      TreeKill(tmp);
    } /* for j */
    fprintf(code, "END\nEND;\n");
    break;
  case 2:
    fprintf(code, "IF tp THEN BEGIN\n");
    for(i=1; i<=NumbOfParams; i++) {
      GetParamNo(i, name, &charge, &form);
      if (form==2)
	RenameSpec(rename, name, charge);
      else
	strcpy(rename, name);
      fprintf(code, "%s=xx_[n%d];\n", rename, i);
    } /* for i */
    fprintf(code, "IF bj THEN BEGIN\n");
    GetParamNo(1, name, &charge, &form);
    if (form==2)
      RenameSpec(rename, name, charge);
    else
      strcpy(rename, name);
    for(j=0; j<NumbOfDynVars; j++) {
      tmp=TreeCreate();
      TreeDerive(tmp, v[j], rename);
      fprintf(code, "gg_[%d, n1]:=", j+1);
      TreePrint(tmp, 2, code);
      fprintf(code, ";\n");
      TreeKill(tmp);
    } /* for j */
    fprintf(code, "END ELSE BEGIN\n");
    for(i=NumbOfParams; i>=1; i--) {
      GetParamNo(i, name, &charge, &form);
      if (form==2)
	RenameSpec(rename, name, charge);
      else
	strcpy(rename, name);
      fprintf(code, "%s:=xx_[n%d];\n", rename, NumbOfParams+1-i);
    } /* for i */
    fprintf(code, "IF bj THEN BEGIN\n");
    GetParamNo(2, name, &charge, &form);
    if (form==2)
      RenameSpec(rename, name, charge);
    else
      strcpy(rename, name);
    for(j=0; j<NumbOfDynVars; j++) {
      tmp=TreeCreate();
      TreeDerive(tmp, v[j], rename);
      fprintf(code, "gg_[%d, n1]:=", j+1);
      TreePrint(tmp, 2, code);
      fprintf(code, ";\n");
      TreeKill(tmp);
    } /* for i */
    fprintf(code, "END\nEND\nEND\n");
    break;
  } /* switch NumbOfParams */

  /* printing Hessian */
  fprintf(code, "PROCEDURE djacobian(xx_:glnarray; VAR dS_:gldjacobian);\n");
  fprintf(code, "BEGIN\n");
  switch (NumbOfParams) {
  case 1:
    need_dd_jac=0;
    break;
  case 2:
    dyn=1;
    for(i=1; i<=NoOfSpec(); i++) {
      GetSpecNo(i, name, &charge);
      if ((IsSpecInConstraint(name, charge)==0) &&
	  (IsSpecParam(name, charge)!=1)) {
	RenameSpec(rename, name, charge);
	fprintf(code, "%s=xx_[%d];\n", rename, dyn);
	dyn++;
      } /* if */
    } /* for i */
    for(i=1; i<=NumOfDynVar(); i++) {
      GetDynVarNo(i, name);
      fprintf(code, "%s=xx_[%d];\n", rename,
	      i+NoOfSpec()/NumOfConstraint());
    } /* for i */
    need_dd_jac=0;
    for(i=0; i<NumbOfDynVars; i++)
      for(j=0; j<NumbOfDynVars; j++)
	for(l=0; l<j; l++) {
	  fprintf(code, "dS_[%d,%d,%d]:=\n", i+1, j+1, l+1);
	  temp=TreeEval(hess[i][j][l]);
	  if (TreeGetError()==NoEval) {
	    need_dd_jac=1;
	    TreePrint(hess[i][j][l], 2, code);
	  } else
	    fprintf(code, "%e", temp);
	  fprintf(code, ";\n");
	  fprintf(code, "dS_[%d,%d,%d]:=dS_[%d,%d,%d];\n", i+1, l+1,
		  j+1, i+1, j+1, l+1);
	} /* for l */
    break;
  } /* switch NumbOfParams */
  fprintf(code, "END;\n");

  /* printing Keldian */
  fprintf(code, "PROCEDURE ddjacobian(xx_:glnarray;VAR ddS_:glddjacobian);\n");
  fprintf(code, "BEGIN\n");
  dyn=1;
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if ((IsSpecInConstraint(name, charge)==0) && 
	(IsSpecParam(name, charge)!=1)) {
      RenameSpec(rename, name, charge);
      fprintf(code, "%s:=xx_[%d];\n", rename, dyn);
      dyn++;
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(code, "%s:=xx_[%d];\n", name, i+NoOfSpec()-NumOfConstraint());
  } /* for i */
  switch (NumbOfDynVars) {
  case 1:
    /* No code is needed */
    break;
  case 2:
    for(i=0; i<NumbOfDynVars; i++)
      for(j=0; j<NumbOfDynVars; j++) 
	for(l=0; l<j; l++)
	  for(k=0; k<l; k++) {
	    fprintf(code, "dds_[%d,%d,%d,%d]:=", i+1, j+1, l+1, k+1);
	    TreePrint(keld[i][j][l][k], 2, code);
	    fprintf(code, ";\n");
	    fprintf(code, "dds_[%d,%d,%d,%d]:=ddS_[%d,%d,%d,%d];\n",
		    i+1, j+1, k+1, l+1, i+1, j+1, l+1, k+1);
	    fprintf(code, "dds_[%d,%d,%d,%d]:=ddS_[%d,%d,%d,%d];\n",
		    i+1, l+1, j+1, k+1, i+1, j+1, l+1, k+1); 
	    fprintf(code, "dds_[%d,%d,%d,%d]:=ddS_[%d,%d,%d,%d];\n",
		    i+1, l+1, k+1, j+1, i+1, j+1, l+1, k+1); 
	    fprintf(code, "dds_[%d,%d,%d,%d]:=ddS_[%d,%d,%d,%d];\n",
		    i+1, k+1, l+1, j+1, i+1, j+1, l+1, k+1); 
	    fprintf(code, "dds_[%d,%d,%d,%d]:=ddS_[%d,%d,%d,%d];\n",
		    i+1, k+1, j+1, l+1, i+1, j+1, l+1, k+1); 
	  } /* for k */
    break;
  } /* switch NumbOfDynVars */
  fprintf(code, "END;\n");
    
  fprintf(code, "PROCEDURE derpinit;\nVAR i : integer;\n");
  GetAndPrintConst("maxout", "maxout", 0, 30.0, code, 2);
  GetAndPrintConst("hh", "hh", 1, 1.0, code, 2);
  GetAndPrintConst("epsmach", "epsmach", 1, 1e-20, code, 2);
  GetAndPrintConst("epsfx", "epsfx", 1, 1e-16, code, 2);
  GetAndPrintConst("cfout", "cfout", 0, 10.0, code, 2);
  GetAndPrintConst("maxititera", "maxititera", 0, 30.0, code, 2);
  GetAndPrintConst("maxitcorrec", "maxitcorrec", 0, 30.0, code, 2);
  GetAndPrintConst("maxithqr", "maxithqr", 0, 30.0, code, 2);
  
  dyn=0;
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if (IsSpecInConstraint(name, charge)==0) {
      dyn++;
      fprintf(code, "xx[%d]:=%e;\n", dyn, GetBeginConc(name, charge));
      temp=GetSpecConst(name, charge, "Hfbstep");
      if (GetError()==NoError) {
	if (temp>0.0)
	  fprintf(code, "hdir[%d]:=1\n;", dyn);
	else
	  fprintf(code, "hdir[%d]:=-1\n;", dyn);
	fprintf(code, "hmax[%d]:=%e;\n", dyn, fabs(temp));
      } /* if */
      temp=GetSpecConst(name, charge, "Hfbxmax");
      if (GetError()==NoError)
	fprintf(code, "xupp[%d]:=%e;\n", dyn, temp);
      temp=GetSpecConst(name, charge, "Hfbxmin");
      if (GetError()==NoError)
	fprintf(code, "xlow[%d]:=%e;\n", dyn, temp);
      temp=GetSpecConst(name, charge, "Hfbpref");
      if (GetError()==NoError)
	fprintf(code, "pref[%d]:=%e;\n", dyn, temp);
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfParameter(); i++) {
    GetParamNo(i, name, &charge, &form);
    if (form==1) {
      GetInitParam(name, &temp);
      fprintf(code, "xx[n%d]:=%e;\n", i, temp);
      temp=GetDirectForParam(name);
      if (temp>0.0)
	fprintf(code, "ndir[n%d]:=1;\n", i);
      else
	fprintf(code, "ndir[n%d]:=-1;\n", i);
      GetDeltaParam(name, &temp);
      fprintf(code, "hmax[n%d]:=%e;\n", i, fabs(temp));
      GetLowHighPrefParam(name, &temp, &temp1, &temp2);
      fprintf(code, "xlow[n%d]:=%e;\n", i, temp);
      fprintf(code, "xupp[n%d]:=%e;\n", i, temp1);
      if ((temp2>1.0) && (temp2<0.0)) 
	fprintf(code, "KnCont: Pref. for %s must between 0 and 1.\n", name);
      else
	fprintf(code, "pref[n%d]:=%e;\n", i, temp2);
    } /* if */
    else {
      GetInitConc(name, charge, &temp);
      fprintf(code, "xx[n%d]:=%e;\n", i, temp);
      temp=GetDirectForConc(name, charge);
      if (temp>0.0)
        fprintf(code, "ndir[n%d]:=1;\n", i);
      else
        fprintf(code, "ndir[n%d]:=-1;\n", i);
      GetDeltaConc(name, charge, &temp);
      fprintf(code, "hmax[n%d]:=%e;\n", i, fabs(temp));
      GetLowHighPrefConc(name, charge, &temp, &temp1, &temp2);
      fprintf(code, "xlow[n%d]:=%e;\n", i, temp);
      fprintf(code, "xupp[n%d]:=%e;\n", i, temp1);
      if ((temp2>1.0) && (temp2<0.0))
	fprintf(code, "KnCont: Pref. for %s(%d) must between 0 and 1.\n", 
		name, (int)charge);
      else
	fprintf(code, "pref[n%d]:=%e;\n", i, temp2);
    } /* else */
  } /* for i */
  fprintf(code, "END;\n");
  fprintf(code, "PROCEDURE derivsinit;\n");
  fprintf(code, "BEGIN\n");
  dyn=1;
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    constraint=IsSpecInConstraint(name, charge);
    if ((constraint==0) && (IsSpecParam(name, charge)==0)) {
      if (charge==0.0)
        fprintf(code, "species[%d]:='%s';\n", dyn, name);
      else { 
	if (charge==MAXFLOAT)
	  fprintf(code, "species[%d]:='%s.';\n", dyn, name);
	else { 
	  if (charge>0.0) {
	  fprintf(code, "species[%d]:='%s", dyn, name);
	  for(j=1; j<=(int)charge; j++)
	    fprintf(code, "+");              
          fprintf(code, "';\n");
        } /* if */ 
	  else {         
	    fprintf(code, "species[%d]:='%s", dyn, name);
	    for(j=1;j<=-(int)charge;j++)
	      fprintf(code, "-");
	    fprintf(code, "';\n");
	  } /* else */
	} /* else */
      } /* else */
      dyn++;
    }; /* if */
  }; /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(code, "species[%d]:='%s';\n", i+NoOfSpec(), name);
  }; /* for i */

  GetAndPrintConst("stime", "tb", 1, 1.0, code, 2);
  GetAndPrintConst("dtime", "dt", 1, 1.0, code, 2);
  GetAndPrintConst("etime", "te", 1, 10.0, code, 2);
  GetAndPrintConst("htime", "hb", 1, 1.0, code, 2);
  GetAndPrintConst("epsr", "epsr", 1, 1e-3, code, 2);
  GetAndPrintConst("epsa", "epsa", 1, 1e-20, code, 2);
  GetStrConst("name", name);
  if (GetError()==NotFound) 
    fprintf(code, "name_datafile:='kinwrk.dat';\n\n");
  else
    fprintf(code, "name_datafile:='%s';\n\n", name);
  dyn=1; 
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if (IsSpecInConstraint(name, charge)==0) { 
      temp=GetBeginConc(name, charge);
      fprintf(code, "xx[%d]:=%e;\n", dyn, temp);
      dyn++;
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(code, "xx[%d]:=%e;\n", i+NoOfSpec()-NumOfConstraint(), 
	    GetInitValue(name));
  } /* for i */
  fprintf(code, "END;\n\n");

  fprintf(code, "PROCEDURE hopfinit;\nBEGIN\nderivsinit;\n");
  fprintf(code, "need_dd_jac:=%s;\n",
	  (need_dd_jac==1)?"TRUE":"FALSE");
  fprintf(code, "END;\n");
    

  StringFree(name);
  StringFree(rename);
} /* KnCont */

