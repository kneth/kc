/***************************************************************************
  IScont - a code generator for kc and cont, see [1, 2].

  CopyWrong 1994 by
  Kenneth Geisshirt (kneth@osc.kiku.dk)
  Department of Theoretical Chemistry
  H.C. Orsted Institute
  Universitetsparken 5
  2100 Copenhagen
  Denmark

  See kc.tex for details.

  References:
  [1]  Chemical waves in reaction-diffusion systems: A numerical study,
       K. Geisshirt, 1994 (M.Sc. thesis).
  [2]  Chaotic Behaviour of Deterministic Dissipative Systems,
       M. Marek and I. Screiber, Academia, 1991.

  Last updated: 13 August 1994
****************************************************************************/

#include <stdio.h>
#include <time.h>
#include "config.h"
#include "tableman.h"
#include "symbmath.h"
#include "codegen.h"
#include "misc.h"

void IScont(FILE *fcode, FILE *input1, FILE *input2) {

  double       charge, coeff;
  char         name[STRING_LENGTH], rename[STRING_LENGTH];
  time_t       timer;
  int          i, j, dyn, form;
  
  timer=time(&timer);

  InitCodeGenVar(NoOfSpec()+NumOfDynVar()-NumOfConstraint(),
		 NumOfConstraint());
  GenerateRateExpr(1, 0, 0, 0);
  GenerateJacobi(1, 0);

  fprintf(fcode, "C ***********************************************\n");
  fprintf(fcode, "C Warning: This file was generated by kc v%s\n", VERSION);
  fprintf(fcode, "C CopyWrong by Kenneth Geisshirt, 1994\n");
  fprintf(fcode, "C %s", ctime(&timer));
  fprintf(fcode, "C ***********************************************\n");

  fprintf(fcode, "        SUBROUTINE MODEL(NDIM,NVAR,N,T,X,F,G,H)\N");
  fprintf(fcode, "        IMCLICIT DOUBLE PRECISION(A-H,O-Z)\n");
  fprintf(fcode, "        DIMENSION X(NDIM),F(NDIM),G(MDIM,NVAR),H(NDIM,NVAR,NDIM)\n");
  fprintf(fcode, "        COMMON/FIXP/PAR(20)\n");
  fprintf(fcode, "        COMMON/VARP/ALPHA,BETA,ARG,PER\n");
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if (IsSpecInConstraint(name, charge)==0) {
      RenameSpec(rename, name, charge);
      fprintf(fcode, "        DOUBLE PRECISION %s\n", rename);
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(fcode, "        DOUBLE PRECISION %s\n", name);
  } /* for i */
  for(i=1; i<=NumOfParameter(); i++) {
    GetParamNo(i, name, &charge, &form);
    if (form==1)
      strcpy(rename, name);
    else
      RenameSpec(rename, name, charge);
    fprintf(fcode, "        DOUBLE PRECISION %s\n", rename);
  } /* for i */

  dyn=1;
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if ((IsSpecInConstraint(name, charge)==0) && 
	(IsSpecParam(name, charge)!=1)) {
      RenameSpec(rename, name, charge);
      fprintf(fcode, "        %s=X(%d)\n", rename, dyn);
      dyn++;
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(fcode, "        %s=X(%d)\n", name, i+NoOfSpec()-NumOfConstraint());
  } /* for i */
  GetParamNo(1, name, &charge, &form);
  if (GetError()==NoError) {
    if (form==2)
      RenameSpec(rename, name, charge);
    else
      strcpy(rename, name);
    fprintf(fcode, "        %s=alpha\n");
  } else 
    fprintf(stderr, "IScont: No parameters.\n");
  GetParamNo(2, name, &charge, &form);
  if (GetError()==NoError) {
    if (form==2)
      RenameSpec(rename, name, charge);
    else
      strcpy(rename, name);
    fprintf(fcode, "        %s=beta\n", rename);
  } /* if */

  for(i=0; i<(NoOfSpec()+NumOfDynVar()-NumOfConstraint()); i++) {
    fprintf(fcode, "        f(%d)=", i+1);
    TreePrint(fcode, 1, v[i]);
    fprintf(fcode, "\n");
  } /* for i */
  fprintf(fcode, "        IF(N.EQ.NDIM) RETURN\n");
  
  /* printing jacobian + df/dalpha, etc */
  for(i=0; i<(NoOfSpec()+NumOfDynVar()-NumOfConstraint()); i++)
    for(j=0; j<=(NoOfSpec()+NumOfDynVar()-NumOfConstraint()); j++) {
      fprintf(fcode, "        g(%d,%d)=", i+1, j+1);
      TreePrint(fcode, 1, jacobi[i][j]);
      fprintf(fcode, "\n");
    } /* for j */
  dyn=0;
  for(j=1; j<=NoOfSpec(); j++) {
    GetSpecNo(j, name, &charge);
    if ((IsSpecInConstraint(name, charge)==0) && 
	(IsSpecParam(name, charge)!=1)) {
      RenameSpec(rename, name, charge);
      tmp=TreeCreate();
      TreeDerive(tmp, v[dyn], rename);
      dyn++;
      fprintf(fcode, "        g(%d,%d)=", dyn, NoOfSpec()-NumOfConstraint()-NumOfParameter()+NumOfDynVar()+dyn);
      TreePrint(tmp, 1, fcode);
      fprintf(fcode, "\n");
      TreeKill(tmp);
    } /* if */
  } /* for j */
