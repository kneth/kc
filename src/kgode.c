/************************************************************************** 
  KGode - a code generator for kc and the KGode (now called KKsolver) 
  package. 

  CopyWrong 1993-1995 by
  Kenneth Gesshirt (kneth@fatou.ruc.dk)
  Department of Life Sciences and Chemistry
  Roskilde University
  P.O. Box 260
  4000 Roskilde
  Denmark

  See kc.tex for details.
  Last updated: 11 May 1995 by KN
***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include "config.h"
#include "symbmath.h"
#include "tableman.h"
#include "codegen.h"
#include "misc.h"


void KGode(FILE* ccode, FILE *hcode) {

  double  charge, temp, coeff;
  char    *name, *rename, *strtmp;
  time_t  timer;
  Tree    v_temp, tmp, temp_tree, tree_temp;
  int     i, j, react_no, finished, constraint, dyn, dyn2;
  int     ngrid, mgrid, boundary, jj;

  name=StringAlloc();
  rename=StringAlloc();
  strtmp=StringAlloc();

  InitCodeGenVar(NoOfSpec()+NumOfDynVar()-NumOfConstraint(),
		   NumOfConstraint(),NoOfReact());

  timer=time(&timer);
  fprintf(hcode, "/*********************************************\n");
  fprintf(hcode, " WARNING: This file was generated by kc v%s\n", VERSION);
  fprintf(hcode, " CopyWrong by Kenneth Geisshirt\n");
  fprintf(hcode, " %s", ctime(&timer));

  fprintf(hcode, "**********************************************/\n");
  fprintf(hcode, "#ifndef _MODEL_HEADER_\n#define _MODEL_HEADER_\n");
  fprintf(ccode, "/*********************************************\n");
  fprintf(ccode, " WARNING: This file was generated by kc v%s\n", VERSION);
  fprintf(ccode, " CopyWrong by Kenneth Geisshirt\n");
  fprintf(ccode, " %s", ctime(&timer));
  fprintf(ccode, "**********************************************/\n");
  fprintf(ccode, "#include \"model.h\"\n");
  fprintf(ccode, "#include <math.h>\n");
  i=NoOfSpec()+NumOfDynVar()-NumOfConstraint(); 
  fprintf(hcode, "#define equa %d\n", i);
  temp=GetConstant("mode");
  if (GetError()==NotFound) 
    temp=0.0;
  switch ((int)temp) {
  case 0:                                        /* normal sim */
    fprintf(hcode, "#undef _DO_PERT_\n");
    break;
  case 1:                                        /* perturbation */
    fprintf(hcode, "#define _DO_PERT_\n");
    break;
  }

  temp=GetConstant("screen");
  if (GetError()==NotFound)
    temp=0.0;
  if (temp==1.0)
    fprintf(hcode, "#define PRINT_ON_SCREEN\n");
  else
    fprintf(hcode, "#undef PRINT_ON_SCREEN\n");

  fprintf(hcode, "double x_[equa],x_pert[equa],xscal_[equa];\n");
  fprintf(hcode, "int do_print[equa];\n");
  fprintf(hcode, "char species[equa][25];\n");

  GenerateRateExpr();
  GenerateJacobi();

  fprintf(ccode, "void reac(double* S_, double* v_) {\n");
  fprintf(hcode, "extern void reac(double *, double *);\n");
  fprintf(ccode, "int j_;\n");
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if (IsSpecInConstraint(name, charge)==0) {
      RenameSpec(rename, name, charge);
      fprintf(ccode, "double %s;\n", rename);
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(ccode, "double %s;\n", name);
  } /* for i */
  dyn=1;
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    RenameSpec(rename, name, charge);
    constraint=IsSpecInConstraint(name, charge);
    if (constraint==0) {
      fprintf(ccode, "%s=S_[%d];\n", rename, dyn-1);
      dyn++;
    } /* if */
  } /* for i*/
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(ccode, "%s=S_[%d];\n", name, i+NoOfSpec()-NumOfConstraint()-1);
  } /* for i */
  dyn=0;
  for(i=1; i<=(NoOfSpec()+NumOfDynVar()-NumOfConstraint()); i++) {
    fprintf(ccode, "v_[%d]=(", i-1);
    TreePrint(v[i-1], 3, ccode);
    fprintf(ccode, ");\n");
  } /* for i */
  fprintf(ccode, "}\n");
  
  /* Printing Jacobi matrix routine */

  fprintf(ccode, "void jacobi(double *S_){\n");
  fprintf(hcode, "extern void jacobi(double *);\n");
  fprintf(ccode, "int j_;\n");
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if (IsSpecInConstraint(name, charge)==0) {
      RenameSpec(rename, name, charge);
      fprintf(ccode, "double %s;\n", rename);
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(ccode, "double %s;\n", name);
  } /* for i */
  dyn=1;
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    RenameSpec(rename, name, charge);
    constraint=IsSpecInConstraint(name, charge);
    if (constraint==0) {
      fprintf(ccode, "%s=S_[%d];\n", rename, dyn-1);
      dyn++;
    } /* if */
  } /* for i*/
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(ccode, "%s=S_[%d];\n", name, i+NoOfSpec()-NumOfConstraint()-1);
  } /* for i */
  for(i=0; i<NoOfSpec()+NumOfDynVar()-NumOfConstraint(); i++)
    for(j=0; j<NoOfSpec()+NumOfDynVar()-NumOfConstraint(); j++) {
      temp=TreeEval(jacobi[i][j]);
      if (TreeGetError()==NoEval) {
	fprintf(ccode, "jacobi_matx[%d][%d]=", i, j);
	TreePrint(jacobi[i][j], 3, ccode);
	fprintf(ccode, ";\n");
      } /* if */
    } /* for j */
  fprintf(ccode, "}\n");

  /* print init routine */
  fprintf(ccode, "void InitValues(void) {\n");
  fprintf(hcode, "extern void InitValues(void);\n");
  fprintf(ccode, "FILE *infile_;\n");
  dyn=0;
  for(i=0; i<NoOfSpec(); i++) {
    GetSpecNo(i+1, name, &charge);
    if (IsSpecInConstraint(name, charge)==0) {
      temp=GetBeginConc(name, charge);
      if (GetError()==NoError) 
	fprintf(ccode, "x_[%d]=%e;\n", dyn, temp);
      else
	fprintf(ccode, "x_[%d]=0.0;\n", dyn);
      if (NumOfPrint()!=0) {           /* print option used */
	if (IsSpecInPrnList(name, charge, 2)==0)
	  fprintf(ccode, "do_print[%d]=1;\n", dyn);
	else
	  fprintf(ccode, "do_print[%d]=0;\n", dyn);
      } else
	fprintf(ccode, "do_print[%d]=1;\n", dyn);
      dyn++;
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    temp=GetInitValue(name);
    fprintf(ccode, "x_[%d]=%e;\n", i+NoOfSpec()-NumOfConstraint()-1, temp);
    if (NumOfPrint()!=0) {           /* print option used */
      if (IsSpecInPrnList(name, 0.0, 1)==0)
	fprintf(ccode, "do_print[%d]=1;\n", 
		i+NoOfSpec()-NumOfConstraint()-1);
      else
	fprintf(ccode, "do_print[%d]=0;\n", 
		i+NoOfSpec()-NumOfConstraint()-1);
    } else
      fprintf(ccode, "do_print[%d]=1;\n", i+NoOfSpec()-NumOfConstraint()-1);
  } /* for i */

  GetAndPrintConst("epsmin", "epsmin_", 1, 0.0, ccode, 3);
  GetAndPrintConst("dtime", "dtime_", 1, 2.0, ccode, 3);
  GetAndPrintConst("prnmode", "prnmode_", 0, 0, ccode, 3);
  GetAndPrintConst("etime", "etime_", 1, 200.0, ccode, 3);
  GetAndPrintConst("stime", "stime_", 1, 0.0, ccode, 3);
  GetAndPrintConst("htime", "htime_", 1, 1.0, ccode, 3);
  GetAndPrintConst("epsr", "epsr_", 1, 1e-5, ccode, 3);
  GetAndPrintConst("epsa", "epsa_", 1, 1e-10, ccode, 3);
  GetAndPrintConst("epse", "epse_", 1, 1e-10, ccode, 3);
  GetAndPrintConst("method", "solver_", 0, 1, ccode, 3);
  GetAndPrintConst("stepadjust", "step_adjustment_factor", 1, 0.9, ccode, 3);
  GetAndPrintConst("maxinc", "steplimit_increase", 1, 1.5, ccode, 3);
  GetAndPrintConst("mindec", "steplimit_decrease", 1, 0.5, ccode, 3);
  GetAndPrintConst("htimemin", "htimemin_", 1, 1.0e-20, ccode, 3);
  GetAndPrintConst("printafter", "begin_print", 1, 0.0, ccode, 3);
  GetAndPrintConst("scaling", "scaling_", 0, 0.0, ccode, 3);
  GetAndPrintConst("debug", "debug_", 0, 1, ccode, 3);

  dyn=0;   
  for(i=1; i<=NoOfSpec(); i++) {
    GetSpecNo(i, name, &charge);
    if (IsSpecInConstraint(name, charge)==0) {
      RenameSpec(rename, name, charge);
      fprintf(ccode, "(void) strcpy(species[%d], \"%s\");\n", dyn, rename);
      dyn++;
    } /* if */
  } /* for i */
  for(i=1; i<=NumOfDynVar(); i++) {
    GetDynVarNo(i, name);
    fprintf(ccode, "(void) strcpy(species[%d], \"%s\");\n", 
	    i+NoOfSpec()-NumOfConstraint()-IsNonAutoSystem()-1, name);
  } /* for i */
  if (IsNonAutoSystem()==1)
    fprintf(ccode, "x_[equa-1]=stime_;\n");
    
  GetStrConst("datafile", name);
  if (GetError()==NotFound) 
    fprintf(ccode, "(void) strcpy(datafilename_,\"kinwrkda\");\n");
  else
    fprintf(ccode, "(void) strcpy(datafilename_,\"%s\");\n", name);
  temp=GetConstant("mode");
  if (GetError()==NotFound) 
    temp=0.0;
  switch ((int)temp) {
  case 0:                                  /* normal sim */
    break;
  case 1:                                  /* perturbation */
    GetAndPrintConst("ptime", "ptime_", 1, 100.0, ccode, 3);
    GetAndPrintConst("dptime", "dptime_", 1, 0.0, ccode, 3);
    dyn=0;
    for(i=1; i<=NoOfSpec(); i++) {
      GetSpecNo(i, name, &charge);
      if (IsSpecInConstraint(name, charge)==0) {
	temp=GetSpecConst(name, charge, "pert");
	if (GetError()==NoError)
	  fprintf(ccode, "x_pert[%d]=%e;\n", dyn, temp);
	else
	  fprintf(ccode, "x_pert[%d]=0.0;\n", dyn);
	dyn++;
      } /* if */
    } /* for */
    break;
  } /* switch temp */

  /* constant elements of the jacobi */
  for(i=0; i<NoOfSpec()+NumOfDynVar()-NumOfConstraint(); i++)
    for(j=0; j<NoOfSpec()+NumOfDynVar()-NumOfConstraint(); j++) {
      temp=TreeEval(jacobi[i][j]);
      if (TreeGetError()==TreeNoError) 
	fprintf(ccode, "jacobi_matx[%d][%d]=%e;\n", i, j, temp);
    } /* for j */  

  fprintf(ccode, "}\n");
  fprintf(hcode, "#endif\n");
  
  StringFree(name);
  StringFree(rename);
  StringFree(strtmp);
} /* KGode */
